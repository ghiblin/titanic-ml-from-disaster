# Titanic ML from Disaster

The goal of this project is to serve a Machine Learn full-stack application to allow user to submit prediction about
possible outcame in case of the Titanic disaster.

## Machine Learning

As I don't have a ML background, I started with [this very usefull article](https://github.com/ViniciusNalaSantos/ML_TitanicAlgoritm/blob/efca7392b931c497e61698d7bf8d9bab35185510/titanic_algoritm.ipynb),
that helped me to train my ML.

In the `machine-learning` forlder, you can find all the material used for training the decision tree algorithm, and
to store it as a pickle to allow a Python script to call it.

## Backend

I used [NestJS](https://nestjs.com/) framework, because I think that it enforce good practices, like Modularization, Dependency Injection and Separation of Concerns.

As I wanted to keep the solution as simple as possible, I kept the implementation at application level, without
creating a dedicated module. If in the future I should need to implement new features, I should move that logic into
a dedicated module.

In the `assets` folder there are all code related with ML part of the project. In particular:

- `predict.py` is the script called to unmarshall picked Tree Model and run a prediction with user parameters,
- `tree_model.pkl` is the marshalled model generated by `train.py` script,
- `train.csv` is the dataset used to train the model.

The main logic is in `/src/app.service.ts` file. I used NodeJS spawn method to execute `predict.py` script and to
pass to it user parameters. This is not the ideal solution: a better one could be to implement a server in Python,
but as Python is not one of my tools, I opted for this approach.

One of the points to failure is the communication between the NodeJS server and the Python Script: as I pass user
arguments as inline parameters, I need to pay attention to the order of the parameters and their domain.

## Frontend

I used [Create React App](https://create-react-app.dev/) for implementing the frontend, with these libraries:

- [Tailwind CSS](https://tailwindcss.com/): it's a utility-first CSS framework. It allows user to inject styles with
  clear class names. Pros: it's fast, flexible and reliable, Cons: there are no reusable components, long class names.
- [React Query](https://github.com/TanStack/query#readme): it's a library that simplify data fetching, and solve the
  `useEffect double render issue` (you shouldn't use `useEffect` to fetch data, but instead use your framework's
  mechanism, as suggested by Dan Abramov). Under the hood, `react-query` caches URL requests.
- [D3.js](https://d3js.org/): it's a JavaScript library for manipulating documents based on data.

I decided to organize the code in features (`predict` and `train-data`) and store common components into the
dedicated folder `components`. Instead of using a router like `react-router`, I kept the solution simple implementing
a basic routing feature into `App.js` using `useState` hook.

## DevOps

I containerized the solution using `Docker`, creating a dedicated `Dockerfile` for each part of the solution:

- for the backend: I started with the oficial Node image (I opted for the Alpine version because is the smallest one)
  and I needed to install all the Python stuff I need to run my script (sorry, the build time for this image is a
  bit too long!),
- for the frontend: I opted for a multi phase solution, where I used a Node image to build my assets and an Nginx
  image to run a dedicated Web Server.

A Docker Compose YAML file allows a quick start up of the project, you just need to run

```bash
docker-compose up
```

to have the frontend listening on localhost:3000 and the backend listening on localhost:4000.
